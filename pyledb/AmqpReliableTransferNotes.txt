Date: Wed, 28 Feb 2007 12:23:33 +0000

[comment -*- outline -*-]

[html <div class="essay_body">]

Notes from discussion between Tony Garnock-Jones and Rafael Schloming,
Sat 24 Feb 2007.

* Things the WIP seems to have been intended to address

It seems like the WIP is intended to address:

 - exactly-once delivery of model/application-level messages (issue 1)
 - recovery of session state after TCP connection interruption (issue 2)
 - recovery of session state on failover (issue 2)

The solution to these issues relies on notions of session and of
negotiated session-level and model-level SLAs.

* Core problem with the WIP

Exactly-once works *only* so long as the checklist of
where-we're-up-to-in-this-transaction is durable. If one side or the
other forgets, the system *will* replay on recovery. Thus we need
idempotency *up to* the durability of the "seen" checklist.

The other thing then is that to leverage the durability properties of
the peer, we need to allow one peer to durably store some information
- perhaps exactly the checklist! - on the other peer for later
retrieval!

Use case: stateless, nondurable transforming proxy, that needs to
transform message identifiers. In order to do exactly once, it needs
to store how it is mapping sequence numbers from one side to sequence
numbers on the other side. If it crashes, it needs to retrieve this
mapping, or via some other means ensure that when it resumes the
sessions to either side that it uses the same mapping. One solution
then is to store the mapping details with one or other or both of the
peers in the sessions to either side. Perhaps session.declare could
take a "userdata" field that is echoed; perhaps there could be a
"session.set" and "session.get" for storing properties on the session
with the same durability SLA as negotiated for the session! That way
the proxy can record what it needs and can live entirely in core.

Quantum extension: hitting the disk is like observation, turning the
speculative into the real. It collapses the wave function.

* Sequence Diagrams of 2pc

** Transfers with three roles in three locations

[b 2PC message transfer, where receiver accepts a message]

@sequence 2pc-receiver-accept 8
  async();
  object(A,"Sender (A)");
  object(C,"Coordinator (C)");
  object(B,"Receiver (B)");
  step();

  active(A);
  message(A,B,"Message(id=I)");
  active(B);
  message(A,C,"Vote(A,id=I,OK)");
  active(C);
  message(B,C,"Vote(B,id=I,OK)");
  message(C,A,"Result(id=I,OK)");
  inactive(A);
  message(C,B,"Result(id=I,OK)");
  inactive(B);
  inactive(C);
  step();

  complete(A);
  complete(C);
  complete(B);

The participants inform the coordinator of their local worldviews. The
coordinator adjudicates, reconciling any differences, and broadcasts
the final decision.

[b 2PC message transfer, where receiver rejects a message]

@sequence 2pc-receiver-reject 8
  async();
  object(A,"Sender (A)");
  object(C,"Coordinator (C)");
  object(B,"Receiver (B)");
  step();

  active(A);
  message(A,B,"Message(id=I)");
  active(B);
  message(A,C,"Vote(A,id=I,OK)");
  active(C);
  message(B,C,"Vote(B,id=I,REJ)");
  message(C,A,"Result(id=I,REJ)");
  inactive(A);
  message(C,B,"Result(id=I,REJ)");
  inactive(B);
  inactive(C);
  step();

  complete(A);
  complete(C);
  complete(B);

Here the local worldviews differ. The coordinator adjudicates by
choosing the REJ worldview as the one to be authoritative.

** Transfers with three roles in two locations

Note: Cases where the receiving party rejects the message elided, as
they are identical in structure to the accept cases.

[b Coordinator with sender]

@sequence 2pc-AC-accept 5
  async();
  object(A,"Sender and Coordinator (A, C)");
  object(B,"Receiver (B)");
  step();

  active(A);
  message(A,B,"Message(id=I)");
  active(B);
  message(A,A,"Vote(A,id=I,OK)");
  active(A);
  message(B,A,"Vote(B,id=I,OK)");
  message(A,B,"Result(id=I,OK)");
  message(A,A,"Result(id=I,OK)");
  inactive(A);
  inactive(A);
  inactive(B);
  step();

  complete(A);
  complete(B);

The sending party also plays the role of the coordinator. Three
signals are sent on the wire: the message to be transferred; the vote
for acceptance; and the result of the transaction.

[b Coordinator with receiver]

@sequence 2pc-BC-accept 5
  async();
  object(A,"Sender (A)");
  object(B,"Receiver and Coordinator (B, C)");
  step();

  active(A);
  message(A,B,"Message(id=I)+Vote(A,id=I,OK)");
  active(B);
  active(B);
  message(B,B,"Vote(A,id=I,OK)");
  message(B,A,"Result(id=I,OK)");
  inactive(A);
  message(B,B,"Result(id=I,OK)");
  inactive(B);
  inactive(B);
  step();

  complete(A);
  complete(B);

The receiving party also plays the role of the coordinator. Two
signals are sent on the wire: a compound signal containing both the
message to be transferred and the sender's vote for acceptance
(perhaps implicitly), and the result of the transaction.

** Options for Receiver's behaviour

The following two diagrams differ in the point at which the receiver
forwards the received message I to the sink. The early-forwarding
process must remember that it has seen I immediately upon receipt of
the Message signal. The late-forwarding process may delay remembering
I until it forwards the message up to the sink, on transaction commit.

Note that since all signals must be idempotent, each party must always
vote consistently the same way for each message. If, on first receipt,
the vote is for REJection, then on each subsequent resending of the
vote, it must also be a REJection vote. This implies that the record
of receipt of a message must contain the vote associated with that
message's transaction.

If the only possible vote is OK, then the receiver only needs to
remember the fact of receipt of each message.

[b Process received message immediately ("early")]

@sequence 2pc-BC-eager-process 8
  async();
  object(FA,"Source");
  object(A,"Sender (A)");
  object(B,"Receiver and Coordinator (B, C)");
  object(FB,"Sink");

  step();

  message(FA,A,"Message");
  active(A);
  message(A,B,"Message(id=I)+Vote(A,id=I,OK)");
  active(B);
  message(B,FB,"Message");
  message(B,A,"Result(id=I,OK)");
  inactive(A);
  inactive(B);
  step();

  complete(FA);
  complete(A);
  complete(B);
  complete(FB);

[b Process received message on transaction completion ("late")]

@sequence 2pc-BC-late-process 8
  async();
  object(FA,"Source");
  object(A,"Sender (A)");
  object(B,"Receiver and Coordinator (B, C)");
  object(FB,"Sink");

  step();

  message(FA,A,"Message");
  active(A);
  message(A,B,"Message(id=I)+Vote(A,id=I,OK)");
  active(B);
  message(B,A,"Result(id=I,OK)");
  inactive(A);
  message(B,FB,"Message");
  inactive(B);
  step();

  complete(FA);
  complete(A);
  complete(B);
  complete(FB);

* Failure analysis

We analysed the general three-role process, illustrated above, to see
if it could recover from failure.

Observations:

 # Each message in the generalised 2pc process must be idempotent. If
   B receives the message more than once, it is part of its role to
   act consistently on each subsequent receipt, retransmitting its
   vote to C and always voting the same way.

Preconditions for robustness:

 # The layer we rely upon to send each signal (arrow between
   participants in the sequence diagrams) may lose signals, but must
   inform us if it suspects packet loss might have happened.

   - If we're relying on TCP, then TCP will tell us when the
     connection is broken. This is the signal that we need to
     resend/restart.

   - If we're relying on UDP, we need to set a timeout. If we haven't
     completed (part of) the transaction by the time the timeout
     fires, that is the signal that we need to resend.

[html </div>]
